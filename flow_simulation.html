<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高精度連續流場模擬 (Seamless CFD)</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #111;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: #222;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            width: 900px;
        }
        h2 { text-align: center; color: #fff; margin-bottom: 5px; font-weight: 300; }
        .desc { text-align: center; color: #888; margin-bottom: 20px; font-size: 0.9em; }
        
        .canvas-box {
            position: relative;
            width: 800px;
            height: 500px;
            margin: 0 auto;
            background: #000;
            border: 1px solid #444;
            border-radius: 4px;
            overflow: hidden;
        }
        canvas { display: block; }
        
        .controls {
            margin-top: 25px;
            padding: 20px;
            background: #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* Slider */
        input[type=range] {
            width: 100%;
            cursor: pointer;
        }
        
        /* Dashboard */
        .dash {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .card {
            background: #444;
            flex: 1;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            border-left: 4px solid #666;
        }
        .card h4 { margin: 0 0 5px 0; font-size: 12px; color: #aaa; }
        .card .val { font-size: 24px; font-weight: bold; }
        
        .ok { border-color: #2ecc71; color: #2ecc71; }
        .warn { border-color: #f1c40f; color: #f1c40f; }
        .bad { border-color: #e74c3c; color: #e74c3c; }

        .legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
        }
        .bar {
            width: 150px;
            height: 10px;
            background: linear-gradient(90deg, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000);
            border-radius: 5px;
        }
    </style>
</head>
<body>

<div class="container">
    <h2>高精度連續流場模擬 (Seamless CFD)</h2>
    <p class="desc">修正彎管處流線斷裂問題，模擬連續的慣性偏移效應</p>

    <div class="canvas-box">
        <canvas id="cfdCanvas" width="800" height="500"></canvas>
    </div>
    
    <div class="legend">
        <span>低流速 (Blue)</span>
        <div class="bar"></div>
        <span>高流速 (Red)</span>
    </div>

    <div class="controls">
        <label>測點位置滑軌 (全程監測)</label>
        <input type="range" id="posSlider" min="0" max="1000" value="100">
        
        <div class="dash">
            <div class="card" id="cardPos">
                <h4>位置區域</h4>
                <div class="val" style="font-size:18px">直管入口</div>
            </div>
            <div class="card" id="cardFlow">
                <h4>偵測風量 (CMM)</h4>
                <div class="val">--</div>
            </div>
            <div class="card" id="cardHz">
                <h4>變頻器 (Hz)</h4>
                <div class="val">--</div>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('cfdCanvas');
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('posSlider');
    
    // Geometry Settings
    const PIPE_W = 80;    // Pipe Width
    const R_TURN = 60;    // Turn Radius (Centerline)
    
    // Coordinates
    const RIGHT_X = 650;  // Center X of Right Leg
    const LEFT_X = 150;   // Center X of Left Leg
    const TOP_Y = 100;    // Center Y of Top Leg
    const BOTTOM_Y = 450; // Bottom Y
    
    // The geometry is inverted U:
    // 1. Right Leg (Up): X=RIGHT_X, Y from BOTTOM to (TOP_Y + R_TURN)
    // 2. Right Turn: Center at (RIGHT_X - R_TURN, TOP_Y + R_TURN)
    // 3. Top Leg (Left): Y=TOP_Y, X from (RIGHT_X - R_TURN) to (LEFT_X + R_TURN)
    // 4. Left Turn: Center at (LEFT_X + R_TURN, TOP_Y + R_TURN)
    // 5. Left Leg (Down): X=LEFT_X ...
    
    // Pre-calculate heatmap once
    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = 800;
    bgCanvas.height = 500;
    const bgCtx = bgCanvas.getContext('2d');
    
    // --- PHYSICS KERNEL ---
    
    // Calculate Velocity vector at any given point (x,y)
    // Returns { v: speed, angle: direction, inside: boolean, n: normalized_pos }
    function getPhysicsAt(x, y) {
        let s = 0; // Distance along path
        let n = 0; // -1 (Inner/Left) to 1 (Outer/Right)
        let angle = 0;
        let inside = false;
        let region = '';

        // Geometric boundary checks
        // 1. RIGHT LEG (UP)
        if (x >= RIGHT_X - PIPE_W/2 && x <= RIGHT_X + PIPE_W/2 && y >= TOP_Y + R_TURN) {
            inside = true;
            region = 'leg1';
            // n: -1 is Left(Inner), 1 is Right(Outer)
            // Wait, standard convention: Let's define n relative to "Curvature Outer".
            // In first turn (Left Turn), Right wall is OUTER.
            // So in leg 1, let's make Right Wall (x > RIGHT_X) be n=1.
            n = (x - RIGHT_X) / (PIPE_W/2);
            s = BOTTOM_Y - y; // s starts at 0 at bottom
            angle = -Math.PI/2; // Up
        }
        
        // 2. RIGHT TURN (Corner 1)
        // Pivot: (RIGHT_X - R_TURN, TOP_Y + R_TURN)
        else {
            let cx1 = RIGHT_X - R_TURN;
            let cy1 = TOP_Y + R_TURN;
            let dx = x - cx1;
            let dy = y - cy1;
            let r = Math.sqrt(dx*dx + dy*dy);
            
            // Check annulus
            if (x > cx1 && y < cy1 && r >= R_TURN - PIPE_W/2 && r <= R_TURN + PIPE_W/2) {
                inside = true;
                region = 'turn1';
                // n: Outer Radius is n=1.
                n = (r - R_TURN) / (PIPE_W/2);
                
                // s: Add Leg1 length + Arc length
                let leg1Len = BOTTOM_Y - (TOP_Y + R_TURN);
                // Angle from 0 (at x axis) to -90 (y axis)
                // atan2(dy, dx). At start (vertical leg top), dx=R, dy=0 -> angle 0.
                // At end (top leg start), dx=0, dy=-R -> angle -PI/2.
                let theta = Math.atan2(dy, dx); // 0 to -1.57
                if(theta > 0) theta = 0; // Clamp
                
                // Arc Length s = r*theta. We use Centerline R.
                let arcS = Math.abs(theta) * R_TURN;
                s = leg1Len + arcS;
                
                angle = theta - Math.PI/2; // Flow direction is tangent
            }
            
            // 3. TOP LEG (Left)
            else if (y >= TOP_Y - PIPE_W/2 && y <= TOP_Y + PIPE_W/2 && x <= RIGHT_X - R_TURN && x >= LEFT_X + R_TURN) {
                inside = true;
                region = 'leg2';
                // n: Top wall is Outer?
                // Entering from Right Turn: Outer was Right wall.
                // Right Turn Outer Wall becomes TOP wall of Top Leg.
                // So Top Wall (y < TOP_Y) is n=1.
                // y is y-coord. n = (TOP_Y - y) / (PIPE_W/2) ?
                // If y is small (Top), TOP_Y - y is positive. Yes.
                n = (TOP_Y - y) / (PIPE_W/2);
                
                let leg1Len = BOTTOM_Y - (TOP_Y + R_TURN);
                let turn1Len = (Math.PI/2) * R_TURN;
                let distIn = (RIGHT_X - R_TURN) - x;
                s = leg1Len + turn1Len + distIn;
                
                angle = -Math.PI; // Left
            }
            
            // 4. LEFT TURN (Corner 2)
            else {
                let cx2 = LEFT_X + R_TURN;
                let cy2 = TOP_Y + R_TURN;
                let dx2 = x - cx2;
                let dy2 = y - cy2;
                let r2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                
                if (x < cx2 && y < cy2 && r2 >= R_TURN - PIPE_W/2 && r2 <= R_TURN + PIPE_W/2) {
                     inside = true;
                     region = 'turn2';
                     // n: Outer Radius is n=1.
                     // Top wall (n=1) becomes Outer Radius of this turn.
                     n = (r2 - R_TURN) / (PIPE_W/2);
                     
                     let leg1Len = BOTTOM_Y - (TOP_Y + R_TURN);
                     let turn1Len = (Math.PI/2) * R_TURN;
                     let leg2Len = (RIGHT_X - R_TURN) - (LEFT_X + R_TURN);
                     
                     // Theta: starts at -PI/2 (top), goes to -PI (left)?
                     // atan2(dy, dx). Start: dx=0, dy=-R -> -PI/2.
                     // End: dx=-R, dy=0 -> -PI.
                     let theta = Math.atan2(dy2, dx2);
                     
                     let angleInTurn = Math.abs(theta - (-Math.PI/2));
                     let arcS = angleInTurn * R_TURN;
                     
                     s = leg1Len + turn1Len + leg2Len + arcS;
                     angle = theta - Math.PI/2;
                }
                
                // 5. LEFT LEG (Down)
                else if (x >= LEFT_X - PIPE_W/2 && x <= LEFT_X + PIPE_W/2 && y >= TOP_Y + R_TURN) {
                    inside = true;
                    region = 'leg3';
                    // n mapping: Outer from turn (Left wall) stays n=1?
                    // Left Turn Outer was Left side.
                    // So Left Wall (x < LEFT_X) is n=1.
                    n = (LEFT_X - x) / (PIPE_W/2);
                    
                    // Calc S... (omitted for brevity, just needs to be large)
                    s = 999; 
                    angle = Math.PI/2; // Down
                }
            }
        }

        if (!inside) return { v:0, inside:false };

        // --- VELOCITY CALCULATION (The Continuous Model) ---
        // 1. Base Profile (Parabola)
        let v = 1 - n*n;
        if(v < 0) v = 0;

        // 2. Skew Logic (The "Red Circle" Fix)
        // We define a skew factor based on 's' (path progress)
        // Skew = 0 (Center), Skew > 0 (Shift to n=1/Outer)
        
        let skew = 0;
        // Constants based on geometry lengths
        const L1 = BOTTOM_Y - (TOP_Y + R_TURN);
        const ARC = (Math.PI/2) * R_TURN;
        
        // Define Skew Zones
        // Zone A: Approaching Turn 1 (Leg 1 end). Skew starts slightly? No, standard pipe flow.
        // Zone B: Inside Turn 1. Skew RAMPS UP.
        if (region === 'leg1') {
            // Pre-turn effect (minor)
            if (y < TOP_Y + R_TURN + 20) skew = 0.1 * (1 - (y - (TOP_Y + R_TURN))/20);
        }
        else if (region === 'turn1') {
            // Ramp up from 0 to 1.5
            // Determine progress in turn (0 to 1)
            let turnProgress = (s - L1) / ARC;
            skew = 1.8 * Math.sin(turnProgress * Math.PI / 2); // Smooth Ease-in
        }
        else if (region === 'leg2') {
            // Decay
            let dist = (s - (L1 + ARC));
            skew = 1.8 * Math.exp(-dist * 0.005);
        }
        else if (region === 'turn2') {
             skew = 0.5 + 1.0 * (s/1000); // Hack for vis
        }
        else if (region === 'leg3') {
             skew = 1.5 * Math.exp(-(y - (TOP_Y+R_TURN))*0.01);
        }

        // Apply Skew to Velocity Profile
        // If skew > 0, we want peak to move towards n=1
        // We use a "Distorted N" approach
        if (skew > 0) {
            let shift = 0.5 * skew; 
            if (shift > 0.8) shift = 0.8;
            
            // Ideally: Peak at n = shift.
            // Function: 1 - ((n - shift)/(1-shift))^2  for right side?
            // Simple visual hack: Multiplier
            let factor = 1 + n * skew; // Boost outer, reduce inner
            if(factor < 0) factor = 0;
            v *= factor;
            
            // Clean up edges
            if (Math.abs(n) > 0.95) v *= 0.5; // Wall friction
        }

        return { v: v, inside: true, angle: angle, n: n };
    }
    
    // --- RENDER HEATMAP ---
    function renderBackground() {
        bgCtx.fillStyle = '#000';
        bgCtx.fillRect(0, 0, 800, 500);
        
        // Pixel Scan (High Quality)
        const imgData = bgCtx.createImageData(800, 500);
        const data = imgData.data;
        
        for(let y=0; y<500; y++) {
            for(let x=0; x<800; x++) {
                let phys = getPhysicsAt(x, y);
                if(phys.inside) {
                    let idx = (y * 800 + x) * 4;
                    // Color Map: Rainbow (Blue -> Cyan -> Green -> Yellow -> Red)
                    // V range approx 0 to 2.0
                    let val = phys.v / 1.8; 
                    if(val>1) val=1;
                    
                    // HSL to RGB conversion helper (Simplified)
                    let hue = (1.0 - val) * 240; // 240(Blue) to 0(Red)
                    
                    // Simple HSL to RGB
                    let s = 100, l = 50;
                    // (Using a quick approximate color ramp for speed)
                    // We can just use Canvas HSL fill for better quality in chunks?
                    // No, pixel manipulation needs RGB.
                    // Let's use a Look-Up or simple logic.
                    // Or... draw rectangles on canvas directly, it's fast enough for once.
                }
            }
        }
        // Since pixel math in JS is verbose, let's use the Canvas API with small rects (2x2)
        // It's fast enough for a one-time bake.
        
        for(let y=0; y<500; y+=2) {
            for(let x=0; x<800; x+=2) {
                let phys = getPhysicsAt(x, y);
                if(phys.inside) {
                     let val = phys.v / 1.6;
                     if(val > 1) val = 1;
                     let hue = 240 * (1 - val);
                     bgCtx.fillStyle = `hsla(${hue}, 100%, 50%, 1)`;
                     bgCtx.fillRect(x, y, 3, 3); // Overlap slightly to fill gaps
                }
            }
        }
        
        // Draw Walls (Outlines)
        bgCtx.strokeStyle = '#666';
        bgCtx.lineWidth = 2;
        
        // Helper path function
        bgCtx.beginPath();
        // Outer Path
        bgCtx.moveTo(RIGHT_X + PIPE_W/2, BOTTOM_Y);
        bgCtx.lineTo(RIGHT_X + PIPE_W/2, TOP_Y + R_TURN);
        bgCtx.arc(RIGHT_X - R_TURN, TOP_Y + R_TURN, R_TURN + PIPE_W/2, 0, -Math.PI/2, true);
        bgCtx.lineTo(LEFT_X + R_TURN, TOP_Y - PIPE_W/2);
        bgCtx.arc(LEFT_X + R_TURN, TOP_Y + R_TURN, R_TURN + PIPE_W/2, -Math.PI/2, -Math.PI, true);
        bgCtx.lineTo(LEFT_X - PIPE_W/2, BOTTOM_Y);
        bgCtx.stroke();
        
        // Inner Path
        bgCtx.beginPath();
        bgCtx.moveTo(RIGHT_X - PIPE_W/2, BOTTOM_Y);
        bgCtx.lineTo(RIGHT_X - PIPE_W/2, TOP_Y + R_TURN);
        bgCtx.arc(RIGHT_X - R_TURN, TOP_Y + R_TURN, R_TURN - PIPE_W/2, 0, -Math.PI/2, true);
        bgCtx.lineTo(LEFT_X + R_TURN, TOP_Y + PIPE_W/2);
        bgCtx.arc(LEFT_X + R_TURN, TOP_Y + R_TURN, R_TURN - PIPE_W/2, -Math.PI/2, -Math.PI, true);
        bgCtx.lineTo(LEFT_X + PIPE_W/2, BOTTOM_Y);
        bgCtx.stroke();
    }

    // --- MAIN LOOP ---
    function animate() {
        // Clear
        ctx.clearRect(0,0,800,500);
        
        // Draw Static Heatmap Background
        ctx.drawImage(bgCanvas, 0, 0);
        
        // Handle Slider Logic
        let pct = slider.value / 1000;
        
        // Map pct to Path Coordinate
        // Total Length estimation
        // Leg1 (300) + Turn1 (100) + Leg2 (400) + Turn2 (100) + Leg3 (300) ~ 1200
        // We define a point crawler
        let trackX, trackY, trackAngle;
        
        // Determine position based on fixed segments for stability
        if(pct < 0.25) { // Leg 1
             trackX = RIGHT_X;
             trackY = BOTTOM_Y - (pct/0.25) * (BOTTOM_Y - (TOP_Y + R_TURN));
             trackAngle = -Math.PI/2;
        } else if (pct < 0.35) { // Turn 1
             let p = (pct - 0.25) / 0.1;
             let ang = p * (-Math.PI/2); // 0 to -90
             trackX = (RIGHT_X - R_TURN) + R_TURN * Math.cos(ang);
             trackY = (TOP_Y + R_TURN) + R_TURN * Math.sin(ang);
             trackAngle = ang - Math.PI/2;
        } else if (pct < 0.70) { // Leg 2 (Top)
             let p = (pct - 0.35) / 0.35;
             let startX = RIGHT_X - R_TURN;
             let endX = LEFT_X + R_TURN;
             trackX = startX - p * (startX - endX);
             trackY = TOP_Y;
             trackAngle = -Math.PI;
        } else if (pct < 0.80) { // Turn 2
             let p = (pct - 0.70) / 0.1;
             let ang = -Math.PI/2 + p * (-Math.PI/2); // -90 to -180
             trackX = (LEFT_X + R_TURN) + R_TURN * Math.cos(ang);
             trackY = (TOP_Y + R_TURN) + R_TURN * Math.sin(ang);
             trackAngle = ang - Math.PI/2;
        } else { // Leg 3
             let p = (pct - 0.80) / 0.2;
             trackX = LEFT_X;
             trackY = (TOP_Y + R_TURN) + p * 300;
             trackAngle = Math.PI/2;
        }
        
        // Draw Probe
        ctx.save();
        ctx.translate(trackX, trackY);
        ctx.rotate(trackAngle);
        
        // Probe Line (Cross Section)
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -PIPE_W/2);
        ctx.lineTo(0, PIPE_W/2);
        ctx.stroke();
        
        // Draw Velocity Profile Curve
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = 2;
        
        let measuredV = 0;
        
        for(let py = -PIPE_W/2; py <= PIPE_W/2; py+=2) {
            // Need to transform local py back to world x,y to query physics
            // Local (0, py) rotated by trackAngle + translated
            // WorldX = trackX + (0*cos - py*sin)
            // WorldY = trackY + (0*sin + py*cos)
            let wx = trackX - py * Math.sin(trackAngle);
            let wy = trackY + py * Math.cos(trackAngle);
            
            let phys = getPhysicsAt(wx, wy);
            let vLen = phys.v * 50;
            
            if(py === -PIPE_W/2) ctx.moveTo(vLen, py);
            else ctx.lineTo(vLen, py);
            
            // Measure at specific spot (e.g. n=0.5, Outer/Top)
            // Local py. Outer is typically negative py in this rotation setup?
            // In Leg1 (Up), angle=-90. py is along X. 
            // -py*sin(-90) = py. WorldX = trackX + py.
            // We defined n=1 as x>RightX. So py>0 is Outer.
            if(Math.abs(py - 20) < 2) measuredV = phys.v;
        }
        ctx.stroke();
        
        // Sensor Tip
        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.arc(0, 20, 4, 0, Math.PI*2); // Probe at Outer side
        ctx.fill();
        
        ctx.restore();
        
        // Update Stats
        updateDash(measuredV, pct);
        
        requestAnimationFrame(animate);
    }
    
    function updateDash(v, pct) {
        // v range 0-2. Target 30 CMM ~ v=1.0
        let flow = v * 30;
        let posText = "";
        let status = "ok";
        
        if(pct < 0.25) posText = "直管 (入口)";
        else if(pct < 0.35) posText = "彎頭 1 (右)";
        else if(pct < 0.70) posText = "水平管 (頂)";
        else if(pct < 0.80) posText = "彎頭 2 (左)";
        else posText = "直管 (出口)";
        
        let hz = 35;
        if(flow > 38) {
            status = "bad";
            hz = 25;
        } else if (flow > 32) {
            status = "warn";
            hz = 30;
        }
        
        document.getElementById('cardPos').querySelector('.val').innerText = posText;
        
        let elFlow = document.getElementById('cardFlow');
        elFlow.querySelector('.val').innerText = flow.toFixed(1);
        elFlow.className = `card ${status}`;
        
        let elHz = document.getElementById('cardHz');
        elHz.querySelector('.val').innerText = hz.toFixed(1);
        elHz.className = `card ${status}`;
    }
    
    // Init
    renderBackground();
    animate();

</script>

</body>
</html>